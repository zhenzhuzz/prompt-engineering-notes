# Claude Code 协作前端开发复盘：从失败到成功的一天

> **日期**: 2025-12-11
> **项目**: Tennis Forehand Scorer WebApp v4.5 → v4.9.3
> **性质**: 个人复盘记录，非对外分享
> **核心主题**: 与 AI 协作修改前端布局的正确方式

---

## 0. Prompt 速查模板 (Quick Reference)

> **使用说明**: 复制下方模板，替换 `[占位符]` 内容，直接发给 Claude Code

---

### 0.1 万能调试模板 (三阶段)

#### 阶段一：调查 (Investigation)

```text
<task>
帮我调查为什么 [元素选择器] 出现 [具体症状]。
</task>

<scope>
- 专注调查这一个问题
- 先找到根本原因
- 不要修复，只分析
</scope>

<check-list>
请检查以下方面：
1. 该元素自身的 CSS 属性
2. 父元素的布局模式 (display: grid/flex/block)
3. 是否有样式覆盖或优先级冲突
4. JS 中是否有相关的 DOM 操作或事件绑定
</check-list>

<output>
告诉我：
- 根本原因是什么
- 在 DevTools 哪里可以验证
- 相关代码的具体位置 (文件名:行号)
</output>
```

#### 阶段二：验证 (Verification) - 用户自己做

```text
我在 F12 DevTools 中看到 [你观察到的内容]，
确认你说的 [AI 的分析结论] 是正确的。
```

或

```text
我在 DevTools 中看到的情况和你说的不一样：
- 你说的: [AI 的结论]
- 我看到的: [实际情况]
请重新分析。
```

#### 阶段三：修改 (Modification)

```text
<task>
确认了。请修改 [具体问题]。
</task>

<action>
在 [文件名] 中把 [具体属性/代码] 改成 [具体值/新代码]。
</action>

<constraints>
- 不要创建新文件
- 不要创建带版本号的新函数 (如 v2, v7)
- 在现有代码基础上修改
- 保持现有的 ID/class 命名不变
</constraints>
```

---

### 0.2 场景专用模板

#### 场景 A：布局问题 (宽度/高度/对齐)

```text
<task>
帮我调查为什么 [选择器] 的 [宽度/高度/位置] 不对。
预期: [应该是什么样]
实际: [现在是什么样]
</task>

<check-list>
重点检查：
- 父元素是否有 display: grid/flex 限制子元素尺寸
- 是否有 max-width/max-height/overflow 限制
- grid-template-columns 或 flex-basis 是否限制了宽度
- 是否被兄弟元素挤压
</check-list>

<constraints>
不要修复，只告诉我原因和在哪验证。
</constraints>
```

#### 场景 B：样式覆盖问题 (颜色/字体/间距不对)

```text
<task>
帮我调查为什么 [选择器] 的 [属性] 不是预期的 [值]。
</task>

<check-list>
重点检查：
- 是否有更高优先级的选择器覆盖 (检查 specificity)
- 是否有 !important 覆盖
- CSS 文件中的声明顺序 (后面的覆盖前面的)
- 是否有内联样式 style="" 覆盖
- 是否有多个 class 冲突 (如同时有 .btn 和 .btn-disabled)
</check-list>

<output>
告诉我在 DevTools Styles 面板中应该看到什么（哪条规则被划线）。
</output>
```

#### 场景 C：交互问题 (点击无反应/事件失效)

```text
<task>
帮我调查为什么 [选择器] 点击没有反应。
</task>

<check-list>
重点检查：
- 事件监听器是否绑定成功 (检查 bindEvent / addEventListener)
- 元素 ID/class 是否与 JS 中的查询选择器一致
- 是否有 pointer-events: none 阻止点击
- 是否被其他元素遮挡 (z-index 问题)
- DOM 是否在事件绑定之后才生成 (时序问题)
- 是否有 e.stopPropagation() 阻止事件冒泡
</check-list>

<constraints>
不要修复，只分析原因。
</constraints>
```

#### 场景 D：数据/状态问题 (显示错误/不更新)

```text
<task>
帮我调查为什么 [功能描述] 显示的数据不对。
预期: [应该显示什么]
实际: [现在显示什么]
</task>

<check-list>
重点检查：
- 数据源是否正确 (变量/状态的值)
- 渲染函数是否被正确调用
- 是否有缓存导致显示旧数据
- 条件判断是否正确 (if/else 逻辑)
</check-list>
```

#### 场景 E：Console 报错 (null/undefined)

```text
<task>
帮我调查这个报错的原因：
[粘贴完整报错信息]
</task>

<check-list>
重点检查：
- 报错指向的代码行
- getElementById/querySelector 是否返回 null
- DOM 元素是否在 JS 执行时已存在
- 变量是否在使用前被正确赋值
</check-list>

<constraints>
不要修复，先告诉我根本原因。
</constraints>
```

---

### 0.3 约束语库 (可复制粘贴)

#### 防止孤岛的约束语 (SPA 项目必加)

```text
<constraints>
- 在现有代码基础上修改，不要重写
- 不要创建新的 CSS/JS 文件
- 不要创建带版本号的新函数 (如 renderUIv2, bindEventsV7)
- 在 [具体文件名] 中修改
- 保持现有的 ID/class 命名不变
</constraints>
```

#### 控制 AI 行为的约束语

```text
# 只分析不修改
不要修复，只分析原因。

# 先讨论后执行
先告诉我你打算怎么改，我确认后再执行。

# 精准修改
只改这一个 [属性/函数/元素]，不要改其他地方。

# 要求验证方法
告诉我如何在 DevTools 中验证你的结论。
```

#### 大型修改的分步约束

```text
<workflow>
这是一个较大的修改，请分步进行：
1. 先告诉我需要改哪些文件的哪些部分
2. 我确认后，先改 [HTML/CSS/JS 其中之一]
3. 我验证后，再改下一部分
</workflow>
```

---

### 0.4 常见前端问题诊断速查表

| 症状 | 最可能原因 | 检查方向 | DevTools 位置 |
|------|-----------|---------|---------------|
| 元素宽度不对 | 父元素 grid/flex 限制 | 父元素 `display` 属性 | Elements → 选中父元素 → Styles |
| 元素高度为 0 | 内容为空或 `overflow:hidden` | `height`, `min-height`, `overflow` | Computed 面板 |
| 点击无反应 | 事件未绑定或 ID 不匹配 | JS 中的 `getElementById` | Console 打印元素 |
| 样式不生效 | 被更高优先级覆盖 | 被划线的样式规则 | Styles 面板 (划线 = 被覆盖) |
| 样式部分生效 | 多个 class 冲突 | 同一属性的多条规则 | Styles 面板 |
| 元素消失 | `display:none` 或 `opacity:0` | `display`, `visibility`, `opacity` | Computed 面板 |
| 元素位置错乱 | `position` 或 `float` 问题 | `position`, `top/left`, `float` | Computed 面板 |
| 元素被遮挡 | `z-index` 问题 | `z-index`, `position` | 3D View 或 Layers |
| 报错 `null` | DOM 查询时元素不存在 | `getElementById` 返回值 | Console + 断点 |
| 报错 `undefined` | 变量未定义或对象属性不存在 | 变量声明和赋值位置 | Console + 断点 |
| 数据不更新 | 渲染函数未调用或缓存 | 函数调用链 | Console.log 调试 |
| 页面加载慢 | 资源过大或请求过多 | 资源大小和数量 | Network 面板 |

---

### 0.5 SPA 特有问题诊断

| 症状 | SPA 特有原因 | 检查方向 |
|------|-------------|---------|
| 切换页面后样式丢失 | CSS 未全局加载 | CSS 是否在 index.html 中引入 |
| 切换页面后事件失效 | 事件绑定在旧 DOM 上 | 事件委托 vs 直接绑定 |
| 新组件只占部分宽度 | 父元素有旧的 grid/flex 布局 | 父元素的 `display` 属性 |
| 多个页面样式冲突 | class 命名不唯一 | 使用更具体的选择器或 BEM 命名 |
| 路由跳转后状态丢失 | 状态未持久化 | 使用全局状态管理或 localStorage |

---

### 0.6 完整对话示例

```text
# 第一轮: 调查

用户:
<task>
帮我调查为什么 #two-layer-container 没有占满整行，只占了大约 20% 宽度。
</task>

<check-list>
请检查：
1. 该元素自身的 width 设置
2. 父元素的布局模式
3. 是否有 grid/flex 限制
</check-list>

<constraints>
不要修复，只分析。告诉我在 DevTools 哪里验证。
</constraints>

---

Claude:
我检查了代码，发现问题在父元素 #anchors-list：

根本原因：
#anchors-list 有 display: grid 和 grid-template-columns: repeat(5, 1fr)
这是旧版 5 列锚点卡片的遗留样式，导致新组件只占 1/5 宽度。

验证方法：
打开 F12 → Elements → 找到 #anchors-list → 查看 Styles 面板
你应该能看到 display: grid 和 grid-template-columns

代码位置：styles.css 第 839-842 行

---

# 第二轮: 验证

用户:
我在 DevTools 中确认看到了 .anchors-list 的 display: grid，确实是这个问题。

---

# 第三轮: 修改

用户:
<task>
确认了。请把 .anchors-list 的布局改为块级。
</task>

<action>
在 styles.css 中把 .anchors-list 的 display: grid 改成 display: block。
</action>

<constraints>
- 只改这一个属性
- 不要改其他样式
</constraints>
```

---

## The Essence

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     一天的核心教训                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   上午 (失败)                              下午 (成功)                       │
│   ┌───────────────────┐                  ┌───────────────────┐             │
│   │ "重写这个页面"     │                  │ "调查原因，不修复" │             │
│   │ AI 自由发挥       │                  │ F12 验证后再改    │             │
│   │ 局部修改          │                  │ 全局统一修改      │             │
│   └───────────────────┘                  └───────────────────┘             │
│           ↓                                      ↓                          │
│   2小时，失败回退                          1小时，一次成功                   │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   💡 核心洞见: 「重写」让 AI 创建孤岛，「修改」让 AI 融入现有系统            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 1. 背景与目标

### 1.1 项目状态

- **起点**: v4.5.2 稳定版本，功能完整
- **目标**: 修改 Step 4 评分页面的布局和配色
  - 白绿渐变配色
  - 65:35 双列布局
  - 紧凑的维度导航

### 1.2 应用架构

```
webapp-v4/ (单页应用 SPA)
├── index.html          - 所有 Step 1-5 的 HTML
├── css/styles.css      - 全局样式
└── js/scoring-wizard.js - 所有交互逻辑

特点: 5 个步骤共享同一套 CSS/JS，通过 display 切换显示
```

---

## 2. 上午时间线：失败之路 (v4.5 → v4.7)

### 2.1 事件序列

```
09:30  Prompt: "对于评分页面布局，先更新 ORG 文档让我看方案"
       → Claude 输出了布局方案，看起来合理
       → 我确认后让它执行

10:00  Prompt: "重写评分页面的 CSS 和 JS 代码"
       → Claude 创建了 scoring-page.css (新文件)
       → Claude 添加了 renderTwoLayerUIv7() (新函数)
       → 我没注意到这是「孤岛」的开始

10:30  测试发现: 所有按钮点击无反应
       → Console: Cannot set properties of null

10:45  Prompt: "按钮没反应，帮我修复"
       → Claude 又改了一轮代码
       → 问题换了一个，新的 bug 出现

11:00  继续修复尝试
       → 发现代码中出现 v4/v7 双版本函数
       → 越改越乱，互相冲突

11:30  决定停止
       → 回退到 v4.5.2
       → 写下知识文档总结教训
```

### 2.2 问题分析：孤岛是怎么形成的

**触发词: 「重写」**

当我说「重写评分页面」时，Claude 理解为：
- 需要全新的代码
- 可以创建新文件
- 可以使用新的命名

**孤岛形成过程**:

```
Step 1: 创建孤岛 CSS
────────────────────────────────────────
原有: styles.css
      └── .scoring-panel { ... }
      └── .error-grid { ... }

新增: scoring-page.css  ← 孤岛
      └── .sp-container { ... }   (新前缀)
      └── .sp-error-grid { ... }  (新命名)

Step 2: 创建孤岛函数
────────────────────────────────────────
原有: renderTwoLayerUI(subItem, key)
      addTwoLayerEventListeners(key, subItem)

新增: renderTwoLayerUIv7(subItem, key)      ← 孤岛
      addTwoLayerEventListenersV7(key, subItem)

Step 3: HTML ID 分裂
────────────────────────────────────────
旧 HTML: <div id="error-grid">
新 HTML: <div id="sp-error-grid">  ← 孤岛

Step 4: 断裂发生
────────────────────────────────────────
旧 JS 代码: document.getElementById('error-grid')
                     ↓
                 返回 null (因为 ID 已经变了)
                     ↓
                 Cannot set properties of null
```

### 2.3 为什么「修复」让问题更糟

```
问题发现
    │
    ▼
让 Claude 修复
    │
    ▼
Claude 在孤岛代码上继续修改
    │
    ├── 尝试让新代码调用旧代码 → 接口不匹配
    │
    ├── 尝试让旧代码兼容新代码 → 更多 hack
    │
    └── 两套代码互相依赖 → 混乱加剧
    │
    ▼
形成「双版本并存」的泥潭
```

**关键教训**: 在错误的基础上修复，只会把错误嵌入得更深。

### 2.4 三个红旗信号（复盘时识别）

| 信号 | 当时的表现 | 应该的反应 |
|------|-----------|-----------|
| 新 CSS 文件 | `scoring-page.css` 被创建 | 立即喊停，问「能在 styles.css 里改吗」 |
| 函数版本号 | `v7` 后缀函数出现 | 立即喊停，问「能直接改原函数吗」 |
| ID 命名变化 | `sp-` 前缀出现 | 立即喊停，问「为什么要改 ID」 |

**我当时没注意到这些信号**，因为我只看最终效果，没有审查 Claude 的具体实现。

---

## 3. 转折点：回退与反思

### 3.1 决定回退

```bash
git checkout 246da66  # 回到 v4.5.2
```

**心理过程**:
- 最初不想放弃 2 小时的工作
- 但发现继续修复只会更乱
- 接受「沉没成本」，干净重来

### 3.2 写知识文档

在回退后，我花时间写了两份知识文档：
- `KNOW_webapp-局部重写陷阱与正确工作流.md`
- `KNOW_webapp-layout-debugging-with-claude.md`

**写文档的价值**:
- 迫使自己想清楚问题本质
- 形成可复用的方法论
- 下次遇到类似问题有参考

---

## 4. 下午时间线：成功之路 (v4.8 → v4.9.3)

### 4.1 策略改变

**核心变化**: 从「让 AI 做」变成「让 AI 帮我分析，我来决定」

```
上午模式:
用户: "改成这样"
  ↓
Claude: 自由发挥，立即执行
  ↓
结果: 不可控

下午模式:
用户: "帮我调查为什么 X 不对，不要修复"
  ↓
Claude: 分析代码，给出原因
  ↓
用户: 用 F12 验证
  ↓
用户: "确认了，改 Y 为 Z"
  ↓
Claude: 精准执行
  ↓
结果: 可控
```

### 4.2 实际对话示例

**场景 1: 布局宽度问题**

```
我: "帮我看为什么 .scoring-panel 下面的 #two-layer-container
    没有占满整行，专注调查这一个原因，不要修复。"

Claude: "我发现 #anchors-list 有 display: grid 和
        grid-template-columns: repeat(5, 1fr)，
        这是旧版 5 列锚点的遗留样式。新组件放进去后只占 1/5。"

我: [打开 F12，找到元素，确认看到 display: grid]

我: "确认了。把 .anchors-list 的 display 改成 block，
    在 styles.css 里改。"

Claude: [执行精准修改]

结果: 一次成功
```

**场景 2: 维度导航重构**

```
我: "把 6 个维度标签改成紧凑的状态胶囊按钮，
    先告诉我你打算怎么改 HTML 和 CSS，我确认后再执行。"

Claude: "计划如下:
        1. HTML: 在 #progress-container 下新增 #dimension-nav
        2. CSS: .dimension-nav-btn 用 flexbox + 固定宽度
        3. JS: renderDimensionTabs() 生成胶囊按钮"

我: "HTML 位置对吗？我理解应该在进度条下面..."

Claude: "是的，在 #scoring-progress-bar 之后"

我: "好，执行吧"

结果: 一次成功
```

### 4.3 成功的关键要素

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     成功协作的四个要素                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   1. 分离「调查」与「修改」                                                  │
│   ┌───────────────────────────────────────────────────────────────────────┐│
│   │ 先让 AI 只分析，不动手                                                 ││
│   │ 用「不要修复」明确限制 AI 的行动范围                                    ││
│   └───────────────────────────────────────────────────────────────────────┘│
│                                                                             │
│   2. 人工验证环节                                                            │
│   ┌───────────────────────────────────────────────────────────────────────┐│
│   │ AI 说的不一定对，用 F12 自己确认                                        ││
│   │ 眼见为实，再做决定                                                      ││
│   └───────────────────────────────────────────────────────────────────────┘│
│                                                                             │
│   3. 精准指令                                                                │
│   ┌───────────────────────────────────────────────────────────────────────┐│
│   │ 说清楚: 改什么 + 改成什么 + 在哪个文件                                  ││
│   │ 不留发挥空间                                                            ││
│   └───────────────────────────────────────────────────────────────────────┘│
│                                                                             │
│   4. 全局思维                                                                │
│   ┌───────────────────────────────────────────────────────────────────────┐│
│   │ 始终在现有文件中修改                                                    ││
│   │ 不创建新文件，不创建新版本函数                                          ││
│   └───────────────────────────────────────────────────────────────────────┘│
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 5. 技术问题深度分析

### 5.1 SPA 孤岛问题的本质

**单页应用的特点**:

```
传统多页应用 (MPA):
┌─────────┐  ┌─────────┐  ┌─────────┐
│ page1   │  │ page2   │  │ page3   │
│ .html   │  │ .html   │  │ .html   │
│ .css    │  │ .css    │  │ .css    │
│ .js     │  │ .js     │  │ .js     │
└─────────┘  └─────────┘  └─────────┘
每个页面独立，可以单独修改

单页应用 (SPA):
┌─────────────────────────────────────┐
│           index.html                │
│  ┌───────┬───────┬───────┬───────┐ │
│  │Step 1 │Step 2 │Step 3 │Step 4 │ │
│  └───────┴───────┴───────┴───────┘ │
│           styles.css                │
│           app.js                    │
└─────────────────────────────────────┘
所有「页面」共享同一套代码，必须一起改
```

**为什么局部修改会失败**:

```
SPA 中的依赖关系:
────────────────────────────────────────
CSS 定义样式
    ↓
HTML 使用 class/id 引用样式
    ↓
JS 通过 id 查找元素并绑定事件
    ↓
用户交互触发 JS 函数
    ↓
JS 函数修改 DOM 或调用其他函数

任何一环的「孤岛化」都会导致链条断裂
```

### 5.2 CSS 优先级冲突实例

下午遇到的一个小问题：正确示范按钮的绿色背景消失

**问题代码**:
```html
<button class="correct-demo-btn-inline video-btn">正确示范</button>
```

**CSS 优先级**:
```css
.correct-demo-btn-inline { background: #4caf50; }  /* 绿色 */
.video-btn { background: #e0e0e0; }                /* 灰色 */
```

**问题**: `.video-btn` 在 CSS 文件中位置更靠后，覆盖了绿色

**解决**: 移除 `video-btn` 类，让按钮只有 `correct-demo-btn-inline`

**教训**: 多个 class 时要注意 CSS 层叠顺序

### 5.3 事件绑定断裂的根因

**正常流程**:
```
renderTwoLayerUI() 生成 HTML
    ↓
HTML 中有 id="error-grid"
    ↓
addTwoLayerEventListeners() 查找 #error-grid
    ↓
绑定 click 事件
    ↓
用户点击，事件触发
```

**断裂流程**:
```
renderTwoLayerUIv7() 生成新 HTML
    ↓
HTML 中有 id="sp-error-grid" (新 ID)
    ↓
addTwoLayerEventListenersV4() 仍在查找 #error-grid (旧 ID)
    ↓
返回 null
    ↓
尝试在 null 上设置属性 → 报错
```

---

## 6. 方法论总结

### 6.1 Prompt 设计原则

| 场景 | 错误写法 | 正确写法 |
|------|---------|---------|
| 调试布局 | "帮我修复布局问题" | "帮我调查为什么 X 宽度不对，不要修复" |
| 修改样式 | "把这个页面改成绿色" | "在 styles.css 中把 .xxx 的背景色改成 #4caf50" |
| 重构组件 | "重写这个组件" | "在现有代码基础上修改，先告诉我方案" |
| 添加功能 | "加一个按钮" | "在 #xxx 容器内添加按钮，用现有的 .btn 类" |

### 6.2 三步工作流

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           三步工作流                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Step 1: 调查                                                              │
│   ┌───────────────────────────────────────────────────────────────────────┐│
│   │ Prompt: "帮我调查 [问题描述]，不要修复"                                 ││
│   │ 期望输出: 根本原因分析 + 相关代码位置                                   ││
│   └───────────────────────────────────────────────────────────────────────┘│
│                              ↓                                              │
│   Step 2: 验证                                                              │
│   ┌───────────────────────────────────────────────────────────────────────┐│
│   │ 动作: 打开 F12 → Elements/Styles → 找到元素 → 确认 AI 说的对不对       ││
│   │ 如果不对: 把看到的情况告诉 AI，让它重新分析                             ││
│   └───────────────────────────────────────────────────────────────────────┘│
│                              ↓                                              │
│   Step 3: 精准修改                                                          │
│   ┌───────────────────────────────────────────────────────────────────────┐│
│   │ Prompt: "把 [文件] 中的 [属性] 改成 [值]"                               ││
│   │ 约束: 不创建新文件，不创建新函数版本                                    ││
│   └───────────────────────────────────────────────────────────────────────┘│
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 6.3 红旗信号检查清单

修改过程中如果看到以下信号，**立即停下来**：

```
□ AI 创建了新的 CSS/JS 文件
□ 函数名出现 v2, v3, vN 后缀
□ 新的 class/id 前缀出现 (如 sp-, new-, v2-)
□ AI 说「为了不影响现有代码」而创建副本
□ 同一功能出现两套实现
```

---

## 7. 待改进点

### 7.1 这次还可以做得更好的地方

1. **更早审查 AI 的实现**
   - 当时只看界面效果，没看代码变更
   - 应该在每次修改后快速扫一眼 diff

2. **更早喊停**
   - 第一轮修复失败后就应该回退
   - 不应该继续在错误基础上打补丁

3. **Prompt 更精确**
   - 上午的 prompt 太笼统（「重写」）
   - 应该一开始就说「在现有代码上修改」

### 7.2 下次类似任务的 Checklist

**修改前**:
- [ ] 确认当前代码是稳定状态
- [ ] 明确修改范围（全局 vs 局部）
- [ ] 准备好「不要修复」「在现有代码上改」等限制语

**修改中**:
- [ ] 每次修改后检查是否有新文件被创建
- [ ] 检查是否有版本号后缀的函数
- [ ] 用 F12 验证 AI 的分析是否正确

**修改后**:
- [ ] 完整测试所有步骤 (Step 1 → 5)
- [ ] 检查控制台是否有报错
- [ ] 确认旧代码是否已清理（无冗余）

---

## 8. 元认知反思

### 8.1 我当时的思维误区

**误区 1: 信任 AI 的实现方式**
- 我只关注「能不能实现」，没关注「怎么实现」
- AI 选择了「最安全」的方式（不改旧代码），但这在 SPA 中是错的

**误区 2: 沉没成本谬误**
- 改了 2 小时不想放弃
- 但继续修复只会浪费更多时间

**误区 3: 把 AI 当成「万能程序员」**
- 以为 AI 理解我的架构意图
- 实际上 AI 只执行字面指令，不理解上下文

### 8.2 正确的心智模型

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     与 AI 协作的正确心智模型                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   AI 不是「理解需求的程序员」                                                │
│   AI 是「执行精确指令的工具」                                                │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   错误模型:                                                                  │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │ 用户: "帮我改布局"                                                   │  │
│   │ 期望: AI 理解我的架构，做出合理决策                                  │  │
│   │ 现实: AI 按字面意思执行，可能创建孤岛                                │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
│   正确模型:                                                                  │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │ 用户: 我是架构师，AI 是执行者                                        │  │
│   │ 用户: 我决定「改哪里」「怎么改」                                      │  │
│   │ 用户: AI 负责「具体实现」和「代码编写」                               │  │
│   │ 用户: 每一步我都要验证和确认                                         │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 9. 版本记录

| 日期 | 版本 | 说明 |
|------|------|------|
| 2025-12-11 | v4.5.2 → v4.7 | 失败，回退 |
| 2025-12-11 | v4.8 → v4.9.3 | 成功，发布 |

**关键提交**:
- `246da66` - v4.5.2 稳定版本（回退点）
- `f0c9ef2` - v4.9.3 紧凑维度导航（成功版本）

---

## 10. 相关文档

| 文档 | 位置 | 说明 |
|------|------|------|
| 局部重写陷阱 | `_knowledge/KNOW_webapp-局部重写陷阱与正确工作流.md` | 上午失败的技术分析 |
| 布局调试方法 | `_knowledge/KNOW_webapp-layout-debugging-with-claude.md` | 下午成功的调试方法 |
| 项目 ORG 文档 | `ORG_SCORING_WEBAPP_V4.md` | 当前架构和组件 ID |

---

**文档状态**: 完整
**最后更新**: 2025-12-11
