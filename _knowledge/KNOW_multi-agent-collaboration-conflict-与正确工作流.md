# 多 Agent 协作冲突与正确工作流

> **Source**: Tennis Forehand Scorer 项目多 Claude Code 会话冲突复盘 (2025-12-19)
> **Context**: 两个 Claude Code 会话同时修改同一项目，导致自动生成文件的方法丢失
> **Core Insight**: 多 Agent 协作时，修改「生成器脚本」比修改「生成的文件」更危险，因为影响是隐式的、延迟的

---

## Golden Rule (黄金准则)

🏆 **「改源不改生，删前先搜用」**

**完整版**:
- 要修改自动生成的文件 → 找到生成器脚本，改源头
- 要删除任何代码/方法 → 先搜索是否有调用方

**安全前提**:
- ✅ 添加新方法/属性 → 安全，不会破坏现有代码
- ⚠️ 删除/重命名接口 → 危险，必须先搜索调用方
- ⚠️ 修改生成器脚本 → 危险，影响所有派生文件

**一句话版本**:
> 「永远修改数据源，永远在删除前搜索依赖」

---

## The Essence (核心精华)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     💡 黄金法则：识别「数据源」与「派生文件」                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   多 Agent 协作的隐患：每个 Agent 只看到自己的上下文，不知道其他 Agent 在做什么│
│                                                                             │
│   ❌ 危险场景：Agent A 修改了生成器脚本，Agent B 依赖生成的文件中的方法       │
│   ✅ 安全做法：明确哪些文件是「源」，哪些是「派生」，修改时考虑下游影响        │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   [Agent A 的视角]       [隐藏的依赖链]        [Agent B 的视角]              │
│   ┌───────────────┐     ┌───────────────┐     ┌───────────────┐            │
│   │ 简化 sync 脚本 │ ──▶ │ rubric-data.js│ ──▶ │ 调用方法失败  │            │
│   │ 删除冗余方法   │     │ 方法被移除    │     │ undefined!    │            │
│   └───────────────┘     └───────────────┘     └───────────────┘            │
│   "我只是清理代码"      (自动生成的文件)       "方法怎么不见了？"            │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   🚨 核心问题: Agent A 的「优化」破坏了 Agent B 的「依赖」                   │
│   ✅ 解决方案: 在生成器脚本中永久添加所需方法，而非手动修改生成的文件         │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 0. Prompt 速查模板 (Quick Reference)

> **使用说明**: 多 Agent 协作时，使用这些模板避免冲突

### 0.1 开始新会话时的声明模板

```text
<task>
我要开始在这个项目上工作。请先帮我了解：
1. 哪些文件是「自动生成的」(派生文件)
2. 哪些文件是「数据源」(需要手动编辑)
3. 有没有其他 Agent 可能正在修改的文件
</task>

<constraints>
- 在修改任何文件前，先告诉我它的上下游依赖
- 如果要修改生成器脚本，列出所有会受影响的派生文件
</constraints>
```

### 0.2 修改生成器脚本前的确认模板

```text
<task>
我需要修改 [脚本名称]，这个脚本会生成 [派生文件列表]。
</task>

<check-list>
请确认：
1. 生成的文件中有哪些方法/属性会被其他代码调用？
2. 我的修改是否会删除或重命名任何现有的方法？
3. 有没有其他代码依赖这些方法？
</check-list>

<constraints>
- 不要删除任何可能被调用的方法
- 如果需要重命名，提供别名保持向后兼容
</constraints>
```

### 0.3 发现方法缺失时的诊断模板

```text
<task>
调用 [对象名].[方法名] 时报错 "is not a function"。
帮我诊断原因，不要直接修复。
</task>

<check-list>
请检查：
1. 这个方法在哪个文件中定义？
2. 这个文件是手动编写的还是自动生成的？
3. 如果是自动生成的，生成器脚本是什么？
4. 生成器脚本最近是否被修改过？
</check-list>

<output>
告诉我：
- 方法丢失的根本原因
- 是否是另一个 Agent/会话修改导致的
- 正确的修复位置（生成器 vs 生成的文件）
</output>
```

---

## 1. 问题复盘

### 1.1 时间线：两个 Agent 的平行工作

```
Session A (数据层重构)                Session B (Mini Report 集成)
──────────────────────────────────    ──────────────────────────────────
14:00  开始工作                       14:00  开始工作
       └── 目标: 简化 sync-rubric.js         └── 目标: 集成 Mini Report UI
       └── 视角: "这些方法没人用"             └── 视角: "调用 RubricData 方法"

14:30  修改 sync-rubric.js            14:30  修改 mcq-engine.js
       └── 删除"冗余"方法模板                 └── 调用 RubricData.getAllIssues()
       └── ✅ 本会话测试通过                  └── 调用 RubricData.getBandColorClass()

15:00  运行 npm run sync              15:00  继续开发其他功能
       └── rubric-data.js 被重新生成         └── 不知道 rubric-data.js 变了
       └── 方法从生成结果中消失               └── 代码还没测试

15:30  会话 A 结束                    15:30  开始测试
       └── "任务完成"                        └── ❌ 报错: getAllIssues is not a function
                                             └── ❌ 报错: getBandColorClass is not a function
                                             └── "为什么方法不见了？"
```

### 1.2 根本原因分析

**项目的数据流架构**:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     数据流：从源到派生                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   [数据源文件]              [生成器脚本]              [派生文件]             │
│   ┌───────────────┐       ┌───────────────┐       ┌───────────────┐        │
│   │ rubric-source │  ──▶  │ sync-rubric   │  ──▶  │ rubric-data   │        │
│   │ .yaml         │       │ .js           │       │ .js           │        │
│   └───────────────┘       └───────────────┘       └───────────────┘        │
│   (手动编辑)               (定义生成模板)           (自动生成)              │
│                                  │                       │                 │
│                                  │                       ▼                 │
│                                  │               ┌───────────────┐        │
│                                  │               │ mcq-engine.js │        │
│                                  │               │ export.js     │        │
│                                  │               │ ...           │        │
│                                  │               └───────────────┘        │
│                                  │               (调用方，依赖方法)         │
│                                  │                                         │
│                                  ▼                                         │
│                           ┌─────────────────────────────────────────┐     │
│                           │  ⚠️ 危险区: 修改生成器影响所有下游       │     │
│                           └─────────────────────────────────────────┘     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

**问题链**:

```
Agent A 修改 sync-rubric.js 的 RubricData 模板
    ↓
删除了 "看起来没用" 的方法定义
    ↓
npm run sync 重新生成 rubric-data.js
    ↓
rubric-data.js 中的方法消失
    ↓
Agent B 的代码调用这些方法
    ↓
运行时报错: "xxx is not a function"
```

### 1.3 为什么这个问题很难发现

| 因素 | 说明 |
|------|------|
| **隐式依赖** | Agent A 不知道有代码调用这些方法 |
| **延迟暴露** | 只有运行 `npm run sync` 后问题才显现 |
| **上下文隔离** | 每个 Claude Code 会话是独立的，不共享状态 |
| **本地测试通过** | Agent A 的修改在其上下文中是"正确"的 |

---

## 2. 冲突类型分类

### 2.1 类型 A: 直接文件冲突 (最容易发现)

```
Agent A                         Agent B
  │                               │
  ├── 编辑 file.js 第 100 行      ├── 编辑 file.js 第 100 行
  │                               │
  └── 保存                        └── 保存 (覆盖 A 的修改)
      ⚠️ Git 会提示冲突
```

**特点**: Git merge 时会提示，容易发现和解决

### 2.2 类型 B: 间接生成冲突 (本次问题) ⚠️

```
Agent A                         Agent B
  │                               │
  ├── 修改 generator.js           ├── 调用 generated.js 的方法
  │                               │
  ├── 运行 npm run sync           │
  │     ↓                         │
  │   generated.js 被重新生成      │
  │   (方法消失)                   │
  │                               ├── 运行代码
  └── 完成                        └── ❌ 报错: method is not a function
      ⚠️ 没有 Git 冲突提示!
```

**特点**: 不会触发 Git 冲突，只有运行时才发现

### 2.3 类型 C: 逻辑依赖冲突

```
Agent A                         Agent B
  │                               │
  ├── 重构 API 接口               ├── 使用旧 API 接口
  │   (返回值格式变了)             │
  │                               │
  └── 完成                        └── ❌ 运行时数据格式错误
      ⚠️ 没有语法错误，但逻辑错了
```

**特点**: 代码能运行，但行为不正确

---

## 3. 反模式识别

### 3.1 反模式 #1: 在不了解下游的情况下修改生成器

| ❌ 错误做法 | ✅ 正确做法 |
|------------|-----------|
| "这个方法看起来没用，删掉" | "先搜索谁调用这个方法" |
| 直接修改生成器模板 | 先列出所有派生文件的调用方 |
| 假设自己的上下文是完整的 | 假设有其他 Agent 在并行工作 |

### 3.2 反模式 #2: 手动修改自动生成的文件

| ❌ 错误做法 | ✅ 正确做法 |
|------------|-----------|
| 直接编辑 `rubric-data.js` 添加方法 | 修改 `sync-rubric.js` 的模板 |
| "先改这里，以后再说" | 找到数据源，从源头修改 |
| 不知道文件是自动生成的 | 检查文件头部注释或项目文档 |

**为什么手动修改生成文件是错误的**:

```
手动添加方法到 rubric-data.js
    ↓
下次运行 npm run sync
    ↓
rubric-data.js 被重新生成
    ↓
手动添加的方法消失
    ↓
问题再次出现
```

### 3.3 反模式 #3: 假设自己是唯一的 Agent

| ❌ 错误认知 | ✅ 正确认知 |
|------------|-----------|
| "我的修改不会影响其他人" | "我的修改可能影响并行工作的 Agent" |
| "这个项目只有我在改" | "可能有其他 Claude Code 会话在运行" |
| "没人告诉我有依赖" | "主动检查是否有依赖" |

---

## 4. 正确工作流

### 4.1 开始工作前：了解项目架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     Step 1: 识别数据流                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   问自己这些问题：                                                           │
│   ┌───────────────────────────────────────────────────────────────────────┐│
│   │ 1. 项目中哪些文件是「自动生成的」?                                      ││
│   │    - 检查 package.json 的 scripts                                      ││
│   │    - 检查文件头部的 "DO NOT EDIT" 注释                                  ││
│   │    - 检查 .gitignore 是否排除了某些生成文件                             ││
│   │                                                                        ││
│   │ 2. 这些文件的「生成器」是什么?                                          ││
│   │    - 通常是 scripts/ 目录下的脚本                                       ││
│   │    - 或者是 build 命令调用的工具                                        ││
│   │                                                                        ││
│   │ 3. 生成的文件被谁「调用」?                                              ││
│   │    - grep 搜索 import/require 语句                                     ││
│   │    - 搜索方法名的调用点                                                 ││
│   └───────────────────────────────────────────────────────────────────────┘│
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 修改生成器脚本时：影响评估

```bash
# 在修改 sync-rubric.js 之前，先检查谁调用 RubricData 的方法

# 1. 列出 rubric-data.js 中导出的所有方法
grep -E "^\s+\w+\(" webapp-v5-api/js/rubric-data.js

# 2. 搜索这些方法的调用点
grep -r "RubricData\." webapp-v5-api/js/ --include="*.js"

# 3. 确认每个方法都有调用方，或者确认真的没有调用
```

### 4.3 发现冲突时：正确的修复路径

```
发现 "xxx is not a function" 错误
        │
        ▼
┌───────────────────────┐
│ 这个方法在哪个文件中？ │
└───────────────────────┘
        │
        ├── 手动编写的文件 → 直接添加方法
        │
        └── 自动生成的文件
            │
            ▼
    ┌───────────────────────┐
    │ 找到生成器脚本        │
    └───────────────────────┘
            │
            ▼
    ┌───────────────────────┐
    │ 在生成器模板中添加方法 │
    └───────────────────────┘
            │
            ▼
    ┌───────────────────────┐
    │ 重新运行生成命令       │
    │ (npm run sync)        │
    └───────────────────────┘
            │
            ▼
    ┌───────────────────────┐
    │ 验证方法已添加到生成文件│
    └───────────────────────┘
```

---

## 5. 本次问题的正确解决方案

### 5.1 错误的修复方式 (临时方案)

```javascript
// ❌ 直接编辑 rubric-data.js 添加方法
// 这些修改会在下次 npm run sync 时被覆盖

const RubricData = {
    // ...现有代码...

    // 手动添加的方法 (危险!)
    getAllIssues() {
        return DIMENSIONS.flatMap(d => d.issues);
    }
};
```

### 5.2 正确的修复方式 (永久方案)

```javascript
// ✅ 修改 sync-rubric.js 中的 RubricData 模板
// 这样每次 npm run sync 都会生成这些方法

const rubricDataTemplate = `
const RubricData = {
    VERSION: RUBRIC_VERSION,
    DIMENSIONS: DIMENSIONS,
    BANDS: TWO_LAYER_BANDS,
    SKILL_LEVELS: SKILL_LEVELS,

    getDimension(id) {
        return DIMENSIONS.find(d => d.id === id);
    },

    // 别名: 兼容其他模块
    getDimensionById(id) {
        return this.getDimension(id);
    },

    getIssue(dimensionId, issueId) {
        const dim = this.getDimension(dimensionId);
        return dim?.issues.find(s => s.id === issueId);
    },

    // 别名: 兼容其他模块
    getIssueById(dimensionId, issueId) {
        return this.getIssue(dimensionId, issueId);
    },

    getAllIssues() {
        return DIMENSIONS.flatMap(d => d.issues);
    },

    getTotalAtoms() {
        return DIMENSIONS.reduce((sum, d) =>
            sum + d.issues.reduce((s, issue) =>
                s + (issue.atoms?.length || 0), 0), 0);
    },

    getBandColorClass(band) {
        if (band >= 4) return 'band-excellent';
        if (band >= 3) return 'band-good';
        if (band >= 2) return 'band-fair';
        return 'band-poor';
    },

    calculateTwoLayerScore(hasSplitStep, selectedAtoms, totalAtoms) {
        if (!hasSplitStep) return 1;
        const errorCount = selectedAtoms?.length || 0;
        if (errorCount === 0) return 5;
        if (errorCount === 1) return 4;
        if (errorCount === 2) return 3;
        return 2;
    }
};
`;
```

### 5.3 为什么使用别名方法

```javascript
// 有些代码调用 getDimensionById()
// 有些代码调用 getDimension()
// 两者是同一个功能

// 提供别名保持向后兼容
getDimension(id) {
    return DIMENSIONS.find(d => d.id === id);
},

getDimensionById(id) {
    return this.getDimension(id);  // 别名指向主方法
},
```

---

## 6. 预防措施

### 6.1 项目级别的预防

**1. 在生成的文件头部添加警告注释**:

```javascript
/**
 * ⚠️ 自动生成的文件 - 请勿手动编辑
 *
 * 生成器: scripts/sync-rubric.js
 * 数据源: data/rubric-source.yaml
 *
 * 如需修改，请编辑生成器脚本或数据源文件，然后运行:
 * npm run sync
 */
```

**2. 在 CLAUDE.md 中声明数据流**:

```markdown
## 数据管理工作流

### 自动生成的文件 (请勿手动编辑)
- `webapp-v5-api/js/rubric-data.js` ← 由 sync-rubric.js 生成
- `webapp-v5-api/data/atoms/*.json` ← 由 sync-rubric.js 生成

### 数据源文件 (应该编辑这些)
- `webapp-v5-api/data/rubric-source.yaml`
- `webapp-v5-api/scripts/sync-rubric.js`
```

### 6.2 工作流级别的预防

**1. 修改前检查清单**:

```
□ 我要修改的文件是数据源还是派生文件？
□ 如果是派生文件，生成器是什么？
□ 如果我修改生成器，会影响哪些下游文件？
□ 有哪些代码依赖这些下游文件的方法/属性？
□ 我的修改会删除或重命名任何现有接口吗？
```

**2. 修改后验证**:

```bash
# 运行生成命令
npm run sync

# 验证生成的文件包含所需方法
grep "getAllIssues" webapp-v5-api/js/rubric-data.js
grep "getBandColorClass" webapp-v5-api/js/rubric-data.js

# 运行调用方的测试
node -e "const {RubricData} = require('./webapp-v5-api/js/rubric-data.js'); console.log(typeof RubricData.getAllIssues)"
```

### 6.3 多 Agent 协作时的注意事项

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     多 Agent 协作原则                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   1. 假设有其他 Agent 在并行工作                                             │
│   ┌───────────────────────────────────────────────────────────────────────┐│
│   │ 不要删除"看起来没用"的代码，除非搜索确认没有调用                        ││
│   │ 不要重命名接口，除非提供向后兼容的别名                                  ││
│   └───────────────────────────────────────────────────────────────────────┘│
│                                                                             │
│   2. 修改生成器时要特别谨慎                                                  │
│   ┌───────────────────────────────────────────────────────────────────────┐│
│   │ 生成器的修改影响是「隐式的」和「延迟的」                                ││
│   │ 其他 Agent 可能正在依赖生成文件中的方法                                 ││
│   └───────────────────────────────────────────────────────────────────────┘│
│                                                                             │
│   3. 添加比删除更安全                                                        │
│   ┌───────────────────────────────────────────────────────────────────────┐│
│   │ 添加新方法不会破坏现有代码                                              ││
│   │ 删除方法可能破坏其他 Agent 的代码                                       ││
│   │ 如需删除，先搜索确认没有调用                                            ││
│   └───────────────────────────────────────────────────────────────────────┘│
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 7. 检查清单

### 7.1 开始新 Agent 会话时

```
□ 阅读 CLAUDE.md 了解项目的数据流
□ 识别哪些文件是自动生成的
□ 了解生成器脚本的位置和用法
□ 检查是否有其他会话正在进行的工作 (git status, 未提交的改动)
```

### 7.2 修改代码前

```
□ 确认要修改的文件是源文件还是派生文件
□ 如果是派生文件，找到对应的生成器
□ 如果要删除代码，先搜索是否有调用
□ 如果要重命名接口，准备提供别名
```

### 7.3 运行生成命令后

```
□ 检查生成的文件是否包含所需的方法/属性
□ 搜索已知的调用方法，确认它们仍然存在
□ 运行基本的功能测试
□ 检查控制台是否有 "is not a function" 等错误
```

---

## 8. 术语表

| 术语 | 定义 |
|------|------|
| **数据源文件** | 需要手动编辑的原始文件，如 YAML 配置、生成器脚本 |
| **派生文件** | 由脚本自动生成的文件，不应手动编辑 |
| **生成器脚本** | 读取数据源、生成派生文件的脚本 |
| **间接冲突** | 通过生成器脚本间接影响派生文件导致的冲突 |
| **别名方法** | 指向同一实现的多个方法名，用于保持向后兼容 |
| **隐式依赖** | 不在同一文件中，但通过生成关系建立的依赖 |

---

## 9. 相关文档

| 文档 | 位置 | 说明 |
|------|------|------|
| 前端协作复盘 | `_knowledge/KNOW_claude-协作前端-20251211复盘.md` | 单 Agent 协作的三步工作流 |
| 局部重写陷阱 | `_knowledge/KNOW_webapp-局部重写陷阱与正确工作流.md` | SPA 孤岛问题 |
| Git 大文件陷阱 | `_knowledge/KNOW_git-large-file-push-trap-与正确工作流.md` | Git 历史清理 |
| 项目配置 | `.claude/CLAUDE.md` | 数据管理工作流定义 |

---

## Key Takeaways

### For 开发者 (多 Agent 项目)

1. **识别数据流** — 搞清楚哪些文件是源，哪些是派生
2. **修改源头** — 永远修改生成器脚本，而非生成的文件
3. **删除前搜索** — 删除任何代码前，先搜索是否有调用
4. **提供别名** — 重命名接口时，保留旧名作为别名

### For AI (Claude Code)

1. **开始工作前了解数据流** — 主动询问项目的生成关系
2. **修改生成器要谨慎** — 列出所有下游影响再动手
3. **假设有并行 Agent** — 不要删除"看起来没用"的代码
4. **添加比删除安全** — 有疑问时选择添加而非删除

### For 团队协作

1. **在生成文件头部添加警告** — 让所有人知道这是自动生成的
2. **在项目文档中声明数据流** — CLAUDE.md 或 README
3. **代码审查检查生成器修改** — 生成器变更需要额外审慎
4. **建立方法调用的依赖图** — 了解谁依赖谁

---

**文档维护**: Yoach 开发团队
**最后更新**: 2025-12-19
**适用范围**: 所有多 Agent (Claude Code) 协作项目，特别是有代码生成流程的项目
