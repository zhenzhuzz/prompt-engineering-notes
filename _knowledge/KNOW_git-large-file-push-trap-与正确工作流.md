# Git 大文件推送陷阱与正确工作流

> **Source**: Tennis Forehand Scorer 项目 Git 推送失败复盘 (2025-12-18)
> **Context**: 分支包含大文件导致 Push 反复超时 (HTTP 408)，多次重试无效
> **Core Insight**: Git 历史会记住一切，删除文件 ≠ 删除历史，必须创建干净分支或重写历史

---

## The Essence (核心精华)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     💡 黄金法则：Git 历史会记住一切                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   大文件一旦进入 Git 历史，即使后续删除，Push 仍需传输完整历史               │
│                                                                             │
│   ❌ 错误认知：删除文件 + .gitignore = 问题解决                              │
│   ✅ 正确认知：必须清理历史 或 创建干净分支                                  │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   [添加大文件]        [删除大文件]        [Push 超时]                        │
│   ┌───────────┐      ┌───────────┐      ┌───────────┐                      │
│   │ commit A  │  ──▶ │ commit B  │  ──▶ │ HTTP 408  │                      │
│   │ +68MB .rar│      │ -68MB .rar│      │ 传输历史  │                      │
│   └───────────┘      └───────────┘      └───────────┘                      │
│   历史中有大文件      文件删了            但历史还在！                        │
│                                                                             │
│   ─────────────────────────────────────────────────────────────────────     │
│                                                                             │
│   🚨 红旗信号：Push 超时 (HTTP 408) 且重试无效                               │
│   ✅ 正确反应：停止重试 → 诊断原因 → 检查历史中的大文件 → 创建干净分支        │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 0. Prompt 速查模板 (Quick Reference)

> **使用说明**: 当 Git Push 失败时，复制下方模板发给 Claude Code

### 0.1 诊断模板 (Push 失败时首先使用)

```text
<task>
Git push 失败了，错误信息是：[粘贴错误信息]
帮我诊断原因，不要重试 push。
</task>

<check-list>
请检查：
1. 历史中是否有大文件 (>10MB)
2. 最近的 commits 是否添加了视频/压缩包等大文件
3. .gitignore 是否正确配置
4. 远程分支状态
</check-list>

<constraints>
- 不要执行 git push
- 只分析原因
- 告诉我需要什么命令来验证
</constraints>
```

### 0.2 解决模板 (确认是大文件问题后)

```text
<task>
确认了是大文件历史导致的 push 超时。
请帮我创建一个干净的分支，只包含代码文件，排除所有视频和压缩文件。
</task>

<action>
1. 从 origin/main 创建新分支
2. 从旧分支 checkout 所有非视频文件
3. 提交并推送
</action>

<constraints>
- 不要修改旧分支
- 新分支名: [指定名称]
- 排除: *.mp4, *.mov, *.rar, *.zip
</constraints>
```

---

## 1. 问题复盘

### 1.1 时间线：从失败到成功

```
14:00  初始状态
       └── 分支 feature/boost-design-2025-12-18 包含 5 个新 commits
       └── 其中 commit 5ce28b9 添加了 ios-mcq-handoff.rar (68MB)

14:10  第一次 Push 尝试
       └── git push -u origin feature/boost-design-2025-12-18
       └── 结果: HTTP 408 超时
       └── ❌ 我的反应: "再 push 一次"

14:20  第二次 Push 尝试
       └── 同样的命令
       └── 结果: 同样的 HTTP 408 超时
       └── ❌ 我的反应: "再试一次"

14:30  第三、四、五次尝试...
       └── 反复执行同样的 push 命令
       └── 结果: 全部超时
       └── ⚠️ 浪费了大量 Tokens 在无效重试上

14:45  尝试解决方案 A: 添加 .gitignore
       └── 创建 .gitignore 排除视频文件
       └── git rm -r --cached 移除已追踪的视频
       └── 提交 .gitignore
       └── 再次 push
       └── 结果: 仍然 HTTP 408 超时
       └── ❌ 原因: .gitignore 只影响未来，不影响历史

15:00  尝试解决方案 B: git filter-branch
       └── 准备执行 git filter-branch 清理历史
       └── 用户拒绝: "为什么要移除所有视频？之前的 commit 都成功了"
       └── ⚠️ 这个方案太激进，会重写整个历史

15:15  ⭐ 转机：诊断根本原因
       └── 执行: git rev-list --objects --all | sort by size
       └── 发现: ios-mcq-handoff.rar (68MB) 在历史中
       └── 发现: 142 个视频文件在历史中
       └── 💡 理解了: 即使删除文件，历史仍然包含它们

15:30  ⭐ 正确解决方案: 创建干净分支
       └── git checkout -b feature/boost-design-clean origin/main
       └── git checkout feature/boost-design-2025-12-18 -- [代码文件]
       └── 只 checkout 非视频文件 (85 个文件)
       └── 提交到新分支

15:45  重命名并推送
       └── git branch -m feature/boost-design-clean feature/boost-design-no-video-2025-12-18
       └── git push -u origin feature/boost-design-no-video-2025-12-18
       └── ✅ 成功！
```

### 1.2 根本原因分析

**Git 的工作原理**:

```
Git 仓库结构
├── .git/objects/          ← 所有历史对象存储在这里
│   ├── blob (文件内容)    ← 大文件的完整内容
│   ├── tree (目录结构)
│   └── commit (提交记录)
└── 工作目录

关键理解:
┌─────────────────────────────────────────────────────────────────────────────┐
│  Commit A: 添加 68MB 文件                                                    │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  .git/objects/abc123... = 68MB 的完整文件内容                        │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                      │                                      │
│                                      ▼                                      │
│  Commit B: 删除该文件                                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  .git/objects/abc123... = 仍然存在！（因为 Commit A 还引用它）        │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                      │                                      │
│                                      ▼                                      │
│  Git Push: 需要传输所有 objects                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  传输 Commit A 的 objects (包含 68MB 文件) ← 这就是超时的原因！       │   │
│  │  传输 Commit B 的 objects                                            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
```

**问题链**:

```
添加 ios-mcq-handoff.rar (68MB) 到 commit
    ↓
文件内容被存储到 .git/objects/
    ↓
后续 commit 删除文件 + 添加 .gitignore
    ↓
文件从工作目录消失，但 .git/objects/ 中仍存在
    ↓
git push 需要传输完整历史
    ↓
GitHub 接收大量数据，超时断开 (HTTP 408)
    ↓
重试 = 重复同样的失败
```

---

## 2. 尝试的解决方案及其失败原因

### 2.1 方案 A: .gitignore + git rm --cached (失败)

**我做了什么**:
```bash
# 创建 .gitignore
echo "*.mp4" >> .gitignore
echo "*.rar" >> .gitignore

# 从 Git 追踪中移除（但保留本地文件）
git rm -r --cached *.mp4
git rm -r --cached *.rar

# 提交
git commit -m "添加 .gitignore"

# 尝试 push
git push
```

**为什么失败**:
```
┌─────────────────────────────────────────────────────────────────────────────┐
│  .gitignore 和 git rm --cached 的作用范围                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   .gitignore: 只影响「未来」的 git add                                       │
│   ┌───────────────────────────────────────────────────────────────────────┐│
│   │  未来的 commit 不会再添加匹配的文件                                    ││
│   │  但已经存在于历史中的文件不受影响                                      ││
│   └───────────────────────────────────────────────────────────────────────┘│
│                                                                             │
│   git rm --cached: 只影响「当前」的暂存区                                    │
│   ┌───────────────────────────────────────────────────────────────────────┐│
│   │  从当前 commit 移除文件                                                ││
│   │  创建一个「删除文件」的新 commit                                       ││
│   │  但历史中添加文件的那个 commit 仍然存在                                ││
│   └───────────────────────────────────────────────────────────────────────┘│
│                                                                             │
│   结论: 这两个命令都不能清理历史中的大文件                                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 方案 B: git filter-branch (用户拒绝)

**Claude 准备执行的命令**:
```bash
git filter-branch --force --index-filter \
  "git rm -rf --cached --ignore-unmatch '*.mp4' '*.rar'" \
  --prune-empty --tag-name-filter cat -- --all
```

**为什么被拒绝**:
- 用户反馈: "之前带视频的 commit 都成功 push 了，为什么要移除所有视频？"
- 这个方案会重写整个仓库历史
- 影响所有分支和所有协作者
- 过于激进，不是必要的

**适用场景**:
- 只有当需要彻底从仓库中移除敏感信息（如密码、密钥）时
- 或者仓库体积过大需要瘦身时

### 2.3 方案 C: 在旧分支上继续操作 (失败)

**尝试的操作**:
```bash
# 在旧分支上
git checkout feature/boost-design-2025-12-18

# cherry-pick 到新分支
git cherry-pick e82b18f --no-commit
```

**为什么失败**:
- Cherry-pick 会带入原 commit 的文件变更
- 如果原 commit 包含大文件的添加/删除，cherry-pick 也会包含
- 本质上没有脱离旧历史

### 2.4 ⭐ 方案 D: 从 origin/main 创建干净分支 (成功！)

**关键转机**: 理解到必须从一个「干净的起点」开始，而不是在「污染的历史」上修补。

**成功的命令序列**:
```bash
# Step 1: 从远程 main 创建全新分支（不包含本地的污染历史）
git checkout -b feature/boost-design-clean origin/main

# Step 2: 先添加 .gitignore（确保不会误加大文件）
git checkout feature/boost-design-2025-12-18 -- .gitignore
git add .gitignore
git commit -m "添加 .gitignore"

# Step 3: 从旧分支 checkout 代码文件（只要代码，不要视频）
git checkout feature/boost-design-2025-12-18 -- \
  "*.json" "*.md" "*.js" "*.yaml" "*.html" \
  ".claude" "_knowledge" "_templates" \
  "webapp-v5-api/data" "webapp-v5-api/js" "webapp-v5-api/scripts"

# Step 4: 提交
git commit -m "V5 架构升级 + MCQ 文档重构 + Boost 推荐系统"

# Step 5: 重命名并推送
git branch -m feature/boost-design-clean feature/boost-design-no-video-2025-12-18
git push -u origin feature/boost-design-no-video-2025-12-18
```

**为什么成功**:
```
┌─────────────────────────────────────────────────────────────────────────────┐
│  干净分支策略                                                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   旧分支历史:                        新分支历史:                             │
│   ┌─────────────┐                   ┌─────────────┐                        │
│   │ commit 1    │                   │ origin/main │ ← 干净起点              │
│   │ (有大文件)  │                   └──────┬──────┘                        │
│   └──────┬──────┘                          │                               │
│          │                                 ▼                               │
│          ▼                          ┌─────────────┐                        │
│   ┌─────────────┐                   │ 新 commit   │                        │
│   │ commit 2    │                   │ (只有代码)  │ ← 没有大文件历史        │
│   │ (有大文件)  │                   └──────┬──────┘                        │
│   └──────┬──────┘                          │                               │
│          │                                 ▼                               │
│          ▼                          ┌─────────────┐                        │
│   ┌─────────────┐                   │ Push 成功！ │                        │
│   │ commit 3    │                   └─────────────┘                        │
│   │ (删除大文件)│                                                          │
│   └──────┬──────┘                   关键: 新分支的历史中                    │
│          │                          从来没有包含过大文件                    │
│          ▼                                                                 │
│   ┌─────────────┐                                                          │
│   │ Push 超时！ │                                                          │
│   └─────────────┘                                                          │
│   因为要传输 commit 1, 2 的大文件                                           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 3. 红旗信号识别

### 3.1 Push 失败时的红旗信号

| 信号 | 具体表现 | 正确反应 |
|------|----------|----------|
| HTTP 408 超时 | `error: RPC failed; HTTP 408 curl 22` | 立即停止重试，检查大文件 |
| 反复失败 | 同一命令执行 2+ 次都失败 | 不要继续重试，切换到诊断模式 |
| "Everything up-to-date" 但报错 | Push 显示 up-to-date 同时有错误 | 检查是否有未推送的本地 commits |
| 长时间无响应 | Push 命令卡住超过 1 分钟 | 可能是大文件传输中，等待或取消 |

### 3.2 与 Claude Code 协作时的红旗信号

| 信号 | 具体表现 | 正确反应 |
|------|----------|----------|
| AI 反复执行同一命令 | 看到 "Running: git push..." 多次 | 立即停止，要求诊断 |
| 错误信息重复出现 | 相同的 HTTP 408 错误 | 停止重试，分析根本原因 |
| AI 建议 "再试一次" | Claude 说 "让我再 push 一次" | 拒绝，要求先诊断 |
| 命令执行时间过长 | Bash 命令超过 2 分钟无输出 | 考虑取消，检查原因 |

---

## 4. 反模式识别

### 4.1 反模式 #1: 盲目重试失败的命令

| ❌ 错误做法 | ✅ 正确做法 |
|------------|-----------|
| "再 push 一次" | "帮我诊断为什么 push 失败" |
| 让 AI 反复执行同一命令 | 失败 2 次后要求分析原因 |
| 认为"可能是网络问题" | 检查具体错误信息 |

**代价**: 今天在无效重试上浪费了大量 Tokens 和时间。

### 4.2 反模式 #2: 认为删除文件等于清理历史

| ❌ 错误认知 | ✅ 正确认知 |
|------------|-----------|
| `rm file` + `git commit` = 文件彻底消失 | 文件从工作目录消失，但历史中仍存在 |
| `.gitignore` 能解决已提交的大文件 | `.gitignore` 只影响未来的 `git add` |
| `git rm --cached` 能清理历史 | 只是创建一个"删除文件"的新 commit |

### 4.3 反模式 #3: 在污染的分支上修补

| ❌ 错误做法 | ✅ 正确做法 |
|------------|-----------|
| 在包含大文件历史的分支上继续工作 | 创建干净分支，重新应用改动 |
| Cherry-pick 包含大文件的 commits | 只 checkout 需要的文件 |
| 尝试各种命令"修复"旧分支 | 放弃旧分支，从干净起点开始 |

---

## 5. 正确工作流

### 5.1 预防：提交前检查

**在 commit 之前检查暂存区是否有大文件**:

```bash
# 检查暂存区文件大小
git diff --cached --stat | head -20

# 列出超过 10MB 的暂存文件
git diff --cached --name-only | xargs -I{} sh -c 'size=$(stat -f%z "{}" 2>/dev/null || stat -c%s "{}"); [ "$size" -gt 10485760 ] && echo "{}: $((size/1048576))MB"'
```

**推荐的 .gitignore 配置**:

```gitignore
# 视频文件 (通常很大)
*.mp4
*.MP4
*.mov
*.MOV
*.avi
*.AVI

# 压缩文件 (可能包含大量内容)
*.rar
*.zip
*.7z
*.tar.gz

# 其他大文件
*.psd
*.ai
*.sketch
```

### 5.2 诊断：确认历史中的大文件

**检查仓库中最大的对象**:

```bash
# 方法 1: 列出所有对象按大小排序
git rev-list --objects --all | \
  git cat-file --batch-check='%(objecttype) %(objectname) %(objectsize) %(rest)' | \
  awk '/^blob/ {print $3, $4}' | \
  sort -rn | head -20

# 方法 2: 检查特定分支的改动
git diff --stat origin/main..HEAD | grep -E "\.(mp4|mov|rar|zip)"
```

### 5.3 解决：决策树

```
Push 失败 (HTTP 408 超时)
        │
        ▼
┌───────────────────────┐
│ 检查历史中是否有大文件 │
└───────────────────────┘
        │
        ├── 没有大文件 → 可能是网络问题，稍后重试
        │
        └── 有大文件
            │
            ▼
    ┌───────────────────────┐
    │ 大文件是否已推送到远程？│
    └───────────────────────┘
            │
            ├── 是 → 远程已有，应该不是大文件问题
            │        检查网络或 GitHub 状态
            │
            └── 否 → 大文件在本地历史中
                │
                ▼
        ┌───────────────────────┐
        │ 选择解决方案           │
        └───────────────────────┘
                │
                ├── 方案 A: 创建干净分支 (推荐)
                │   └── 从 origin/main 创建新分支
                │   └── 只 checkout 代码文件
                │   └── 重新提交
                │
                ├── 方案 B: git filter-branch
                │   └── 重写整个历史
                │   └── 适用于需要彻底清理的情况
                │   └── 影响所有协作者
                │
                └── 方案 C: BFG Repo-Cleaner
                    └── 第三方工具，比 filter-branch 快
                    └── 需要安装 Java
```

---

## 6. 与 Claude Code 协作的最佳实践

### 6.1 什么时候应该停止让 AI 重试

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     停止重试的信号                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   🚨 立即停止:                                                               │
│   ┌───────────────────────────────────────────────────────────────────────┐│
│   │ • 同一命令失败 2 次以上                                                ││
│   │ • 看到相同的错误信息重复出现                                           ││
│   │ • 命令执行超过 2 分钟无进展                                            ││
│   │ • AI 说 "让我再试一次" 但上次已经失败                                  ││
│   └───────────────────────────────────────────────────────────────────────┘│
│                                                                             │
│   ✅ 切换到诊断模式:                                                         │
│   ┌───────────────────────────────────────────────────────────────────────┐│
│   │ "停止。帮我诊断为什么失败，不要重试。"                                  ││
│   │ "分析错误原因，给我解决方案。"                                          ││
│   └───────────────────────────────────────────────────────────────────────┘│
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 6.2 正确的 Prompt 模板

**❌ 避免的 Prompt**:

```text
"再 push 一次"
"重试"
"继续执行"
```

**✅ 推荐的 Prompt**:

```text
# Push 失败时
"Push 失败了，帮我诊断原因，不要重试。检查：
1. 历史中是否有大文件
2. 远程分支状态
3. 网络错误类型"

# 确认问题后
"确认是大文件导致的。帮我创建干净分支，排除所有视频文件。"

# 需要重试时
"我确认网络没问题，请再 push 一次。如果还失败，停下来告诉我。"
```

### 6.3 Token 节省策略

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     三步工作流：诊断 → 验证 → 执行                            │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Step 1: 诊断                                                              │
│   ┌───────────────────────────────────────────────────────────────────────┐│
│   │ Prompt: "帮我诊断 [问题]，不要执行修复"                                 ││
│   │ AI 输出: 分析报告 + 建议的解决方案                                      ││
│   │ Token 消耗: 低                                                         ││
│   └───────────────────────────────────────────────────────────────────────┘│
│                              ↓                                              │
│   Step 2: 验证                                                              │
│   ┌───────────────────────────────────────────────────────────────────────┐│
│   │ 用户: 执行 AI 给的诊断命令，确认分析正确                                ││
│   │ Token 消耗: 无                                                         ││
│   └───────────────────────────────────────────────────────────────────────┘│
│                              ↓                                              │
│   Step 3: 执行                                                              │
│   ┌───────────────────────────────────────────────────────────────────────┐│
│   │ Prompt: "确认了，请执行方案 X"                                          ││
│   │ AI: 执行具体操作                                                        ││
│   │ Token 消耗: 中                                                         ││
│   └───────────────────────────────────────────────────────────────────────┘│
│                                                                             │
│   ⚠️ 对比: 盲目重试                                                          │
│   ┌───────────────────────────────────────────────────────────────────────┐│
│   │ "再试一次" × 5 次 = 5 次完整的 push 尝试                                ││
│   │ 每次都要等待超时 (1-2 分钟)                                             ││
│   │ Token 消耗: 高，且无效                                                  ││
│   └───────────────────────────────────────────────────────────────────────┘│
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 7. 检查清单

### 7.1 提交前检查

```
□ 暂存区是否有视频文件 (*.mp4, *.mov)?
□ 暂存区是否有压缩文件 (*.rar, *.zip)?
□ 暂存区是否有超过 10MB 的文件?
□ .gitignore 是否已配置排除大文件?
□ 如果必须提交大文件，是否考虑使用 Git LFS?
```

### 7.2 Push 失败时检查

```
□ 错误信息是什么？(HTTP 408 = 超时，通常是大文件)
□ 是第几次失败？(2 次以上应该停止重试)
□ 本地分支比远程多了哪些 commits?
□ 这些 commits 是否添加了大文件?
□ 历史中是否有大文件 (即使后来删除了)?
```

### 7.3 创建新分支时检查

```
□ 基于哪个分支创建？(origin/main 通常是干净的)
□ 新分支是否继承了大文件历史?
□ 是否只 checkout 需要的文件，而不是整个 commit?
```

---

## 8. 术语表

| 术语 | 定义 |
|------|------|
| **Git 历史** | 所有 commits 的链式记录，包含每个 commit 的完整快照 |
| **Git Objects** | Git 存储数据的基本单位，包括 blob(文件内容)、tree(目录)、commit(提交) |
| **HTTP 408** | Request Timeout，请求超时，通常因为传输数据量过大 |
| **git rm --cached** | 从暂存区移除文件，但不删除工作目录中的文件 |
| **.gitignore** | 配置 Git 忽略特定文件的规则文件，只影响未追踪的文件 |
| **git filter-branch** | 重写 Git 历史的命令，可以从所有 commits 中移除特定文件 |
| **干净分支** | 历史中不包含大文件的分支 |
| **污染历史** | 包含大文件的 Git 历史，即使文件后来被删除 |

---

## 9. 相关文档

| 文档 | 位置 | 说明 |
|------|------|------|
| 前端协作复盘 | `_knowledge/KNOW_claude-协作前端-20251211复盘.md` | AI 协作的三步工作流 |
| 局部重写陷阱 | `_knowledge/KNOW_webapp-局部重写陷阱与正确工作流.md` | SPA 孤岛问题 |
| Git 官方文档 | https://git-scm.com/book/en/v2/Git-Internals-Git-Objects | Git 对象存储原理 |

---

## Key Takeaways

### For 开发者 (使用 AI 编码)

1. **Git 历史会记住一切** — 删除文件不等于清理历史
2. **Push 失败 2 次就应该停止重试** — 盲目重试浪费时间和 Tokens
3. **创建干净分支是最可靠的解决方案** — 不要在污染的历史上修补
4. **预防胜于治疗** — 提交前检查大文件，配置好 .gitignore

### For AI (Claude Code)

1. **Push 失败时先诊断，不要重试** — 检查历史中的大文件
2. **识别大文件问题后推荐干净分支方案** — 不要继续在旧分支上操作
3. **用户说"再试一次"时要质疑** — 如果上次已经失败，应该先诊断
4. **给出预估和警告** — 告诉用户可能需要多长时间，可能会失败

### For 团队协作

1. **建立 .gitignore 标准** — 项目初始化时就配置好
2. **考虑 Git LFS** — 如果确实需要版本控制大文件
3. **Code Review 检查大文件** — PR 中看到大文件应该拒绝
4. **分享这个文档** — 让团队成员了解大文件陷阱

---

**文档维护**: Yoach 开发团队
**最后更新**: 2025-12-18
**适用范围**: 所有使用 Git 的项目，特别是与 AI 协作编码时
