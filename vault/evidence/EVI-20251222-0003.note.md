# 多 Agent 协作冲突调试笔记

## Environment

- **OS**: Windows 11
- **工具**: Claude Code (多实例/多会话)
- **项目**: vault/ 知识资产库
- **场景**: 多个 Claude Code 实例并发修改同一仓库

## Symptom

多个 Agent 同时操作时出现：
1. 文件内容被意外覆盖（一个 agent 的修改被另一个 agent 的全文件重写覆盖）
2. Schema/Validator 等制度文件出现不一致状态
3. Git 合并冲突频繁，且冲突内容难以理解

典型错误模式：
```
Agent A: 修改 CARD-0001.md 的 Claim 部分
Agent B: 同时重写整个 CARD-0001.md（添加新字段）
结果: Agent A 的修改丢失
```

## Minimal Repro

1. 启动两个 Claude Code 会话，指向同一仓库
2. Agent A: 编辑 `vault/cards/CARD-0001.md` 的 Claim 段落
3. Agent B: 同时用 Write 工具重写整个 `vault/cards/CARD-0001.md`
4. Agent B 的重写覆盖了 Agent A 的局部修改

## Expected vs Actual

- **Expected**: 两个 agent 的修改能被合并或至少提示冲突
- **Actual**: 后写入的 agent 直接覆盖，先写入的修改丢失，无警告

## Root Cause Hypothesis

1. **竞态条件 (Race Condition)**: 文件系统层面没有锁机制，后写入者覆盖前者
2. **作用域过大**: Agent 倾向于使用 Write（全文件重写）而非 Edit（局部修改）
3. **缺乏协商机制**: 多 agent 没有"文件所有权"概念，同时修改制度文件

## Fix

### 规则 1: 缩小作用域 (Scope Reduction)
- 优先使用 Edit 工具（局部修改）而非 Write 工具（全文件重写）
- 如必须重写，先 Read 获取最新内容，再基于最新内容修改

### 规则 2: 文件所有权 (File Ownership)
- 制度文件（schema/validator/governance）: 单写多读，同一时间只允许一个 agent 修改
- 资产文件（evidence/cards）: 多写可合并，以 Card 为最小并发单元

### 规则 3: 顺序编辑 (Sequential Edits)
- 对制度文件的修改必须串行：先完成一个 agent 的修改，验证通过后，再开始下一个

## Prevention

### 冲突处理优先级
```
1. Evidence (append-only) - 最高优先，不可丢失
2. Cards (claim 不被混淆) - 次高优先
3. Know (叙事可重建) - 最低优先
```

### 并发协作规则
```
┌─────────────────────────────────────────────────────┐
│  制度文件 (单写多读)        │  资产文件 (多写可合并)   │
├─────────────────────────────────────────────────────┤
│  - SCHEMA.md               │  - evidence/*.yml       │
│  - validate_vault.py       │  - evidence/*.note.md   │
│  - GOVERNANCE.md           │  - cards/*.md           │
│  - CONTRACT.md             │  - know/*.md (谨慎)     │
└─────────────────────────────────────────────────────┘
```

### 操作前检查
1. 运行 `git status` 确认无未提交更改
2. 确认目标文件当前无其他 agent 正在修改
3. 优先 Edit 局部修改，避免 Write 全文件重写

## Artifacts

- 治理文档: `vault/GOVERNANCE.md#Multi-agent Collaboration Rules`
- 相关知识: `_knowledge/KNOW_multi-agent-collaboration-conflict-与正确工作流.md`
